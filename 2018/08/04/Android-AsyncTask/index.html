<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/logo.jpg?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/logo.jpg?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.jpg?v=5.1.4" color="#222">





  <meta name="keywords" content="Android,Android消息机制,">










<meta name="description" content="前言Android应用的主线程（UI线程）肩负着绘制用户界面和及时响应用户操作的重任，为了避免”ANR”，就要确保主线程时刻保持较高的响应性.为了做到这一点，我们就要把耗时的任务移出主线程，那么耗时的任务交给谁来完成呢？答案就是工作者线程。Android开发中我们通常让主线程负责前台用户界面的绘制以及响应用户的操作，让工作者线程在后台执行一些比较耗时的任务。Android中的工作者线程主要有Asy">
<meta name="keywords" content="Android,Android消息机制">
<meta property="og:type" content="article">
<meta property="og:title" content="Android AsyncTask">
<meta property="og:url" content="http://yoursite.com/2018/08/04/Android-AsyncTask/index.html">
<meta property="og:site_name" content="Zeng&#39;s Blog">
<meta property="og:description" content="前言Android应用的主线程（UI线程）肩负着绘制用户界面和及时响应用户操作的重任，为了避免”ANR”，就要确保主线程时刻保持较高的响应性.为了做到这一点，我们就要把耗时的任务移出主线程，那么耗时的任务交给谁来完成呢？答案就是工作者线程。Android开发中我们通常让主线程负责前台用户界面的绘制以及响应用户的操作，让工作者线程在后台执行一些比较耗时的任务。Android中的工作者线程主要有Asy">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/2018/08/04/Android-AsyncTask/1.jpg">
<meta property="og:image" content="http://yoursite.com/2018/08/04/Android-AsyncTask/2.jpg">
<meta property="og:image" content="http://yoursite.com/2018/08/04/Android-AsyncTask/3.jpg">
<meta property="og:image" content="http://yoursite.com/2018/08/04/Android-AsyncTask/4.jpg">
<meta property="og:updated_time" content="2018-11-15T10:44:22.300Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android AsyncTask">
<meta name="twitter:description" content="前言Android应用的主线程（UI线程）肩负着绘制用户界面和及时响应用户操作的重任，为了避免”ANR”，就要确保主线程时刻保持较高的响应性.为了做到这一点，我们就要把耗时的任务移出主线程，那么耗时的任务交给谁来完成呢？答案就是工作者线程。Android开发中我们通常让主线程负责前台用户界面的绘制以及响应用户的操作，让工作者线程在后台执行一些比较耗时的任务。Android中的工作者线程主要有Asy">
<meta name="twitter:image" content="http://yoursite.com/2018/08/04/Android-AsyncTask/1.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/08/04/Android-AsyncTask/">





  <title>Android AsyncTask | Zeng's Blog</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Zeng's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">心之所向，素履以往</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/04/Android-AsyncTask/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zeng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zeng's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Android AsyncTask</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-04T18:12:43+08:00">
                2018-08-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Android应用的主线程（UI线程）肩负着绘制用户界面和及时响应用户操作的重任，为了避免”ANR”，就要确保主线程时刻保持较高的响应性.为了做到这一点，我们就要把耗时的任务移出主线程，那么耗时的任务交给谁来完成呢？答案就是工作者线程。Android开发中我们通常让主线程负责前台用户界面的绘制以及响应用户的操作，让工作者线程在后台执行一些比较耗时的任务。Android中的工作者线程主要有AsyncTask、IntentService、HandlerThread，它们本质上都是对线程或线程池的封装。</p>
<p>AsyncTask是我们日常中广泛使用的一种工作者线程，它的方便之处在于可以在后台任务执行完毕时根据返回结果相应的更新UI。下面我们来研究一下它的工作原理。</p>
<h3 id="AsyncTask简介"><a href="#AsyncTask简介" class="headerlink" title="AsyncTask简介"></a>AsyncTask简介</h3><p>AsyncTask是对Handler与线程池的封装。使用它的方便之处在于能够更新用户界面，当然这里更新用户界面的操作还是在主线程中完成的，但是由于AsyncTask内部包含一个Handler，所以可以发送消息给主线程让它更新UI。另外，AsyncTask内还包含了一个线程池。使用线程池的主要原因是避免不必要的创建及销毁线程的开销。设想下面这样一个场景：有100个只需要0.001ms就能执行完毕的任务，如果创建100个线程来执行这些任务，执行完任务的线程就进行销毁。那么创建与销毁进程的开销就很可能成为了影响性能的瓶颈。通过使用线程池，我们可以实现维护固定数量的线程，不管有多少任务，我们都始终让线程池中的线程轮番上阵，这样就避免了不必要的开销。</p>
<p>在这里简单介绍下AsyncTask的使用方法，为后文对它的工作原理的研究做铺垫，关于AsyncTask的详细介绍大家可以参考官方文档或是相关博文。</p>
<p>AsyncTask是一个抽象类，我们在使用时需要定义一个它的派生类并重写相关方法。AsyncTask类的声明如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AsyncTask&lt;Params, Progress, Result&gt;</span><br></pre></td></tr></table></figure>
<p>我们可以看到，AsyncTask是一个泛型类，它的三个类型参数的含义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Params：doInBackground方法的参数类型；</span><br><span class="line">Progress：AsyncTask所执行的后台任务的进度类型；</span><br><span class="line">Result：后台任务的返回结果类型。</span><br></pre></td></tr></table></figure>
<p>我们再来看一下AsyncTask类主要为我们提供了哪些方法：</p>
<ul>
<li>onPreExecute() //此方法会在后台任务执行前被调用，用于进行一些准备工作 </li>
<li>doInBackground(Params… params) //此方法中定义要执行的后台任务，在这个方法中可以</li>
<li>publishProgress来更新任务进度（publishProgress内部会调用onProgressUpdate方法）</li>
<li>onProgressUpdate(Progress… values) //由publishProgress内部调用，表示任务进度更</li>
<li>onPostExecute(Result result) //后台任务执行完毕后，此方法会被调用，参数即为后台任务的返回结果 </li>
<li>onCancelled() //此方法会在后台任务被取消时被调用</li>
</ul>
<p>以上方法中，除了doInBackground方法由AsyncTask内部线程池执行外，其余方法均在主线程中执行。</p>
<p>AsyncTask的使用方法比较简单，无非是创建一个AsyncTask派生类对象，重写其doInBackground()函数，然后在合适时机调用这个对象的execute()或executeOnExecutor()函数即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span>&lt;<span class="title">Void</span>, <span class="title">Void</span>, <span class="title">Void</span>&gt; ｛</span></span><br><span class="line"><span class="class">    // . . . . . .</span></span><br><span class="line"><span class="class">    @<span class="title">Override</span></span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">Void</span> <span class="title">doInBackground</span>(<span class="title">Void</span>... <span class="title">param</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//. . . . . .</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClickListener</span> <span class="keyword">implements</span> <span class="title">View</span>.<span class="title">OnClickListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (v.getId()) &#123;</span><br><span class="line">        <span class="keyword">case</span> R.id.scan_btn:</span><br><span class="line">            testTask();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        . . . . . .</span><br><span class="line">    &#125;</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            MyTask t = <span class="keyword">new</span> MyTask(i+<span class="number">100</span>);</span><br><span class="line">            t.execute();    <span class="comment">// 调用execute()即可</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>一般情况下，我们会像上面代码中这样调用AsyncTask的execute()函数，这样，投入执行的task会串行执行。不过，有时候我们也希望task们可以并行执行，此时只需把execute()换成executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR)即可。</p>
<p>###AsyncTask的内部机制</p>
<p>AsyncTask本身是个抽象的泛型基类，正如前面所说，在实际使用时，我们必须定义它的派生类，并在实现AsyncTask派生类时，重写其doInBackground()成员函数。</p>
<p>作为一种异步执行的任务，AsyncTask是依靠内部的线程池来完成任务调度的。大体上说，AsyncTask内部搞了两个静态的执行器，分别表示成AsyncTask.THREAD_POOL_EXECUTOR 和 AsyncTask.SERIAL_EXECUTOR，前者是可并行执行的执行器（线程池），后者是串行执行的执行器（线程池）。</p>
<p>AsyncTask的构造函数如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new asynchronous task. This constructor must be invoked on the UI thread.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AsyncTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mWorker = <span class="keyword">new</span> WorkerRunnable&lt;Params, Result&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Result <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            mTaskInvoked.set(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class="line">            <span class="comment">//noinspection unchecked</span></span><br><span class="line">            Result result = doInBackground(mParams);</span><br><span class="line">            Binder.flushPendingCommands();</span><br><span class="line">            <span class="keyword">return</span> postResult(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    mFuture = <span class="keyword">new</span> FutureTask&lt;Result&gt;(mWorker) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">done</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                postResultIfNotInvoked(get());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                android.util.Log.w(LOG_TAG, e);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"An error occurred while executing </span></span><br><span class="line"><span class="string">                doInBackground()"</span>, e.getCause());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (CancellationException e) &#123;</span><br><span class="line">                postResultIfNotInvoked(<span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造函数的注释中说的很明确，必须在UI线程里构造AsyncTask对象。而且构造函数里为两个重要的成员：mWorker和mFuture赋了值，这个我们后文再细说。</p>
<h4 id="AsyncTask的execute"><a href="#AsyncTask的execute" class="headerlink" title="AsyncTask的execute()"></a>AsyncTask的execute()</h4><p>我们先回过头看前文曾经提到的AsyncTask的execute()函数，其代码如下：<br><code>frameworks/base/core/java/android/os/AsyncTask.java</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@MainThread</span><br><span class="line">public final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) &#123;</span><br><span class="line">    return executeOnExecutor(sDefaultExecutor, params);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为params参数是可变长参数，所以execute()可以接受0到n个参数。注意，execute()和executeOnExecutor()都必须在UI线程里调用。</p>
<p>execute()只是简单地调用executeOnExecutor()而已，它传递的静态变量sDefaultExecutor引用的就是串行执行器AsyncTask.SERIAL_EXECUTOR：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR;</span><br></pre></td></tr></table></figure>
<p>executeOnExecutor()的代码截选如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@MainThread</span><br><span class="line">public final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec,</span><br><span class="line">        Params... params) &#123;</span><br><span class="line">    . . . . . .</span><br><span class="line">    . . . . . .</span><br><span class="line">    mStatus = Status.RUNNING;</span><br><span class="line">    onPreExecute();</span><br><span class="line">    mWorker.mParams = params;</span><br><span class="line">    exec.execute(mFuture);  // 注意，mFuture本身实现了Runnable接口</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说，最终还是在调用执行器的execute()函数，只不过会把一个mFuture委托给执行器去回调。</p>
<p>默认情况下使用的串行执行器类是SerialExecutor，它的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private static class SerialExecutor implements Executor &#123;</span><br><span class="line">    final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;();</span><br><span class="line">    Runnable mActive;</span><br><span class="line"></span><br><span class="line">    public synchronized void execute(final Runnable r) &#123; // 参数r一般就是mFuture引用的对象</span><br><span class="line">        mTasks.offer(new Runnable() &#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    r.run();</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    scheduleNext();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        if (mActive == null) &#123;</span><br><span class="line">            scheduleNext();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected synchronized void scheduleNext() &#123;</span><br><span class="line">        if ((mActive = mTasks.poll()) != null) &#123;</span><br><span class="line">            THREAD_POOL_EXECUTOR.execute(mActive);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码里可以看到，所谓的串行执行器内部，其实也是在复用THREAD_POOL_EXECUTOR，只不过利用对mActive的判断，把调用的流程改成串行的了。</p>
<p>SerialExecutor内部使用的是java.util.ArrayDeque队列，它的poll()函数可以检索并移除此队列的头部，如果返回null，则表示此队列已经取空了。每次摘取一个列头，并记录在mActive变量里，然后交给THREAD_POOL_EXECUTOR来处理。</p>
<p>ThreadPoolExecutor是java提供的线程池实现。总之，线程池会在后续的某个时刻，回调上面插入的Runnable对象的run()。在executeOnExecutor()函数里，我们已经看到向执行器添加了AsynctTask的mFuture成员，而mFuture本身实现了Runnable接口，以后回调就是回调mFuture的run()函数。</p>
<h4 id="AsyncTask和线程池的协作"><a href="#AsyncTask和线程池的协作" class="headerlink" title="AsyncTask和线程池的协作"></a>AsyncTask和线程池的协作</h4><h5 id="AsyncTask里的mFuture"><a href="#AsyncTask里的mFuture" class="headerlink" title="AsyncTask里的mFuture"></a>AsyncTask里的mFuture</h5><p>AsyncTask的mFuture非常重要，它的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private final FutureTask&lt;Result&gt; mFuture;</span><br></pre></td></tr></table></figure>
<p>类型为FutureTask，其实现可以参考JDK里的代码：<br>【java/util/concurrent/FutureTask.java】</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt;</span><br></pre></td></tr></table></figure>
<p>【java/util/concurrent/FunnableFuture.java】</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt;</span><br></pre></td></tr></table></figure>
<p>在前文列出AsyncTask构造函数时，我们已经看到mFuture的创建代码了，注意，在创建FutureTask对象时，传入了mWorker，它会被记入mFuture内部（如果分析JDK的代码，可以看到大体上就是记入mFuture.sync.callable了）。后续在被线程池执行时，这个mWorker才是最核心的对象。</p>
<p>欲了解详情，我们先得看看AsyncTask机制运用的线程池。在AsyncTask类里这样定义线程池成员的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; sPoolWorkQueue =</span><br><span class="line">        <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(<span class="number">128</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor THREAD_POOL_EXECUTOR;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE_SECONDS, TimeUnit.SECONDS,</span><br><span class="line">            sPoolWorkQueue, sThreadFactory);</span><br><span class="line">    threadPoolExecutor.allowCoreThreadTimeOut(<span class="keyword">true</span>);</span><br><span class="line">    THREAD_POOL_EXECUTOR = threadPoolExecutor;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor SERIAL_EXECUTOR = <span class="keyword">new</span> SerialExecutor();</span><br></pre></td></tr></table></figure>
<p>注意，线程池都是记在静态变量里的，它的生命期和进程的生命期基本一致。</p>
<p>细心的同学还记得，前文在定义AsyncTask派生类时，我们写的是private static class，大家不要忘记加static，否则就是写了一个普通内嵌类，而普通内嵌类对象内部会隐式地引用其外部类，这样当我们的task对象记入线程池后，就有可能导致task的外部类（很有可能是个Activity或Service）对象在较长时间内都不能被垃圾回收机制回收，从而导致内存泄漏。</p>
<p>本文的重点并不想太深入线程池的内部机理，我们只做必要的探讨即可。我们大体上只需知道线程池里的线程会执行FutureTask的run()函数即可。而FutureTask的run()代码如下：<br>【java/util/concurrent/FutureTask.java】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.innerRun();</span><br><span class="line">&#125;</span><br><span class="line">而FutureTask.Sync的innerRun()代码如下：</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">innerRun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!compareAndSetState(READY, RUNNING))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    runner = Thread.currentThread();</span><br><span class="line">    <span class="keyword">if</span> (getState() == RUNNING) &#123; <span class="comment">// recheck after setting thread</span></span><br><span class="line">        V result;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            result = callable.call();  <span class="comment">// 这一步间接调用到AsyncTask的doInBackground()。</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            setException(ex);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        set(result);  <span class="comment">// 如果不出异常的话，会对call返回的结果执行set()操作。</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        releaseShared(<span class="number">0</span>); <span class="comment">// cancel</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中会调用callable.call()，这一步就会间接调用到AsyncTask的doInBackground()。再接下来，如果不出异常的话，会对call()返回的结果执行set()操作。大家还记得前文WorkerRunnable实现的call()函数吗？它最后返回语句为：return postResult(result);现在设置的就是postResult()返回的Result对象，其归根溯源就是doInBackground()返回的那个Result对象。</p>
<p>FutureTask的set()函数的代码如下：<br>【java/util/concurrent/FutureTask.java】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(V v)</span> </span>&#123;</span><br><span class="line">    sync.innerSet(v);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">innerSet</span><span class="params">(V v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> s = getState();</span><br><span class="line">            <span class="keyword">if</span> (s == RAN)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span> (s == CANCELLED) &#123;</span><br><span class="line">                releaseShared(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(s, RAN)) &#123;</span><br><span class="line">                result = v;</span><br><span class="line">                releaseShared(<span class="number">0</span>);</span><br><span class="line">                done();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>结果记录进Sync类的result成员，然后回调FutureTask的done()函数，这也就回调到前文我们看到的AysncTask的mFuture的done()函数了。我们再列一下mFuture的代码：<br>【frameworks/base/core/java/android/os/AsyncTask.java】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mFuture = <span class="keyword">new</span> FutureTask&lt;Result&gt;(mWorker) &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">done</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            postResultIfNotInvoked(get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            android.util.Log.w(LOG_TAG, e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"An error occurred while executing </span></span><br><span class="line"><span class="string">            doInBackground()"</span>, e.getCause());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CancellationException e) &#123;</span><br><span class="line">            postResultIfNotInvoked(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>done()里面做的无法一些善后处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postResultIfNotInvoked</span><span class="params">(Result result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> wasTaskInvoked = mTaskInvoked.get();</span><br><span class="line">    <span class="keyword">if</span> (!wasTaskInvoked) &#123;</span><br><span class="line">        postResult(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="AsyncTask里的mWorker"><a href="#AsyncTask里的mWorker" class="headerlink" title="AsyncTask里的mWorker"></a>AsyncTask里的mWorker</h5><p>AsyncTask的另一个重要成员是mWorker，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private final WorkerRunnable&lt;Params, Result&gt; mWorker;</span><br></pre></td></tr></table></figure>
<p>除了在executeOnExecutor()里会为mWorker的mParams成员赋值外，AsyncTask一般不会直接操作mWorker。mWorker会间接记录进mFuture。当mFuture被回调时，系统会间接回调mWorker的call()成员函数，而这个call()函数是整个AsyncTask的核心行为。</p>
<p>现在我们可以画一张AsyncTask的示意图：</p>
<p><img src="/2018/08/04/Android-AsyncTask/1.jpg" alt=""></p>
<p>其实，当一个AsyncTask被安插进线程池时，线程池主要关心的是其mFuture成员引用的FutureTask。所以我们可以画出如下示意图：</p>
<p><img src="/2018/08/04/Android-AsyncTask/2.jpg" alt=""></p>
<p>当回调发生时，最终间接执行到mWorker成员的call()函数，在介绍AsyncTask的构造函数时，我们已经见过该函数的代码，现在再列一遍：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mWorker = <span class="keyword">new</span> WorkerRunnable&lt;Params, Result&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        mTaskInvoked.set(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);<span class="comment">// 设为后台线程</span></span><br><span class="line">        <span class="comment">//noinspection unchecked</span></span><br><span class="line">        Result result = doInBackground(mParams);</span><br><span class="line">        Binder.flushPendingCommands();   <span class="comment">// ???</span></span><br><span class="line">        <span class="keyword">return</span> postResult(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>看到了吗，当线程池里的某个线程回调到上面的call()函数时，会先把线程优先级设置为“后台线程”，然后会调用doInBackground()函数。大家还记得吧，前文说过我们在实现一个AsyncTask派生类时，主要重写的就是这个doInBackground()函数，现在终于派上用场了。</p>
<p>上面代码中还调用了一个不常见的函数：Binder.flushPendingCommands()。这个函数对应的注释是这样说的：（本函数）会将所有在当前线程里挂起的“Binder命令”扔回内核驱动。一般可以在执行那些有可能阻塞较长时间的操作之前调用一下该函数，这样可以确保挂起的对象引用被及时释放，避免“持有执行对象的进程”占据比“实际需要持有的时间”更长的时间。这部分说明让人有点儿迷惑，或许此处的调用仅仅只是为了在doInBackground()之后做一些binder驱动层的清理动作。</p>
<h5 id="UI线程和AsyncTask工作线程之间的协作"><a href="#UI线程和AsyncTask工作线程之间的协作" class="headerlink" title="UI线程和AsyncTask工作线程之间的协作"></a>UI线程和AsyncTask工作线程之间的协作</h5><p>回调的call()函数最终还会通过postResult()，发回一条MESSAGE_POST_RESULT消息。postResult()的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private Result postResult(Result result) &#123;</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT,</span><br><span class="line">            new AsyncTaskResult&lt;Result&gt;(this, result));</span><br><span class="line">    message.sendToTarget();</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处的getHandler()得到的实际是一个可向UI线程发送消息的handler（即AsyncTask的静态成员sHandler）。getHandler()的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private static Handler getHandler() &#123;</span><br><span class="line">    synchronized (AsyncTask.class) &#123;</span><br><span class="line">        if (sHandler == null) &#123;</span><br><span class="line">            sHandler = new InternalHandler();</span><br><span class="line">        &#125;</span><br><span class="line">        return sHandler;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里搞了个类似单例的sHandler，类型为InternalHandler：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private static class InternalHandler extends Handler &#123;</span><br><span class="line">    public InternalHandler() &#123;</span><br><span class="line">        super(Looper.getMainLooper());    // 用于向UI线程发送消息！</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;RawUseOfParameterizedType&quot;&#125;)</span><br><span class="line">    @Override</span><br><span class="line">    public void handleMessage(Message msg) &#123;</span><br><span class="line">        AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj;</span><br><span class="line">        switch (msg.what) &#123;</span><br><span class="line">            case MESSAGE_POST_RESULT:</span><br><span class="line">                // There is only one result</span><br><span class="line">                result.mTask.finish(result.mData[0]);</span><br><span class="line">                break;</span><br><span class="line">            case MESSAGE_POST_PROGRESS:</span><br><span class="line">                result.mTask.onProgressUpdate(result.mData);</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从InternalHandler的构造函数可以看到，postResult()最终就是向UI线程发回MESSAGE_POST_RESULT消息的。</p>
<p>当UI线程最终处理MESSAGE_POST_RESUTL消息时，会调用AsyncTask的finish()。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private void finish(Result result) &#123;</span><br><span class="line">    if (isCancelled()) &#123;</span><br><span class="line">        onCancelled(result);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        onPostExecute(result);</span><br><span class="line">    &#125;</span><br><span class="line">    mStatus = Status.FINISHED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一方面，用户在编写doInBackground()时，还可以在合适时机调用publishProgress()，向UI线程发出MESSAGE_POST_PROGRESS消息。publishProgress()的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@WorkerThread</span><br><span class="line">protected final void publishProgress(Progress... values) &#123;</span><br><span class="line">    if (!isCancelled()) &#123;</span><br><span class="line">        getHandler().obtainMessage(MESSAGE_POST_PROGRESS,</span><br><span class="line">                new AsyncTaskResult&lt;Progress&gt;(this, values)).sendToTarget();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个消息同样被刚刚说到的InternalHandler处理，处理时会回调AsyncTask的onProgressUpdate()。</p>
<p>关于UI线程和执行AsyncTask的线程之间的交互，我们可以画一张示意图如下：</p>
<p><img src="/2018/08/04/Android-AsyncTask/3.jpg" alt=""></p>
<p>这张图反映了一个AsyncTask对象在运作时，大体上是如何被UI线程和工作线程调用执行的。</p>
<h5 id="AsyncTask的内部状态"><a href="#AsyncTask的内部状态" class="headerlink" title="AsyncTask的内部状态"></a>AsyncTask的内部状态</h5><p>细心的读者还会发现，AsyncTask在finish()时会把自己的状态置为Status.FINISHED。简单说来，AsyncTask可以处于3种状态，分别是PENDING、RUNNING、FINISHED。这3种状态的切换很简单，示意图如下：</p>
<p><img src="/2018/08/04/Android-AsyncTask/4.jpg" alt=""></p>
<h5 id="cancel动作"><a href="#cancel动作" class="headerlink" title="cancel动作"></a>cancel动作</h5><p>当然，用户还可以随时中途放弃执行当前任务。不管是在主线程处理MESSAGE_POST_PROGRESS时，还是在工作线程处理doInBackground()时，用户都可以调用cancel()函数。该函数的代码如下：<br><code>frameworks/base/core/java/android/os/AsyncTask.java</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public final boolean cancel(boolean mayInterruptIfRunning) &#123;</span><br><span class="line">    mCancelled.set(true);</span><br><span class="line">    return mFuture.cancel(mayInterruptIfRunning);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>java/util/concurrent/FutureTask.java</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean cancel(boolean mayInterruptIfRunning) &#123;</span><br><span class="line">    return sync.innerCancel(mayInterruptIfRunning);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>java/util/concurrent/FutureTask.java</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">boolean innerCancel(boolean mayInterruptIfRunning) &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int s = getState();</span><br><span class="line">        if (ranOrCancelled(s))</span><br><span class="line">            return false;</span><br><span class="line">        if (compareAndSetState(s, CANCELLED))</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    if (mayInterruptIfRunning) &#123;</span><br><span class="line">        Thread r = runner;</span><br><span class="line">        if (r != null)</span><br><span class="line">            r.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    releaseShared(0);</span><br><span class="line">    done();</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单地说，cancel()动作会将mCancelled设为true，这样以后再调用isCancelled()时，就会返回true。前文我们已经看过AsyncTask的finish()的代码，现在再列一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private void finish(Result result) &#123;</span><br><span class="line">    if (isCancelled()) &#123;</span><br><span class="line">        onCancelled(result);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        onPostExecute(result);</span><br><span class="line">    &#125;</span><br><span class="line">    mStatus = Status.FINISHED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，如果该任务是被用户cancel的，那么finish时执行的会是onCancelled()，而不是onPostExecute()。另外，为了确保在用户cancel任务之后，该任务能真的快速退出，我们应该在doInBackground()里周期性地检查一下isCancelled()的返回值，一旦发现，就立即退出。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>关于AsyncTask的知识，我们就先说这么多。现在大体总结一下：</p>
<ol>
<li>使用AsyncTask时，主要是重写其派生类的doInBackground()，而且该函数会在线程池的某个工作线程里被回调的；</li>
<li>必须在UI线程调用AsyncTask的execute()或executeOnExecutor()；</li>
<li>可以在doInBackground()里的合适时机调用publishProgress()，向UI线程通知工作进展；</li>
<li>可以随时调用cancel()，放弃执行任务。</li>
</ol>
<h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><ol>
<li>AsyncTask不与任何组件绑定生命周期。在Activity或 Fragment中使用 AsyncTask时，最好在Activity或 Fragment的 onDestory（）调用 cancel(boolean)；</li>
<li>若AsyncTask被声明为Activity的非静态内部类，当Activity需销毁时，会因AsyncTask保留对Activity的引用 而导致Activity无法被回收，最终引起内存泄露。AsyncTask应被声明为Activity的静态内部类；</li>
<li>当Activity重新创建时（屏幕旋转 / Activity被意外销毁时后恢复），之前运行的AsyncTask（非静态的内部类）持有的之前Activity引用已无效，故复写的onPostExecute()将不生效，即无法更新UI操作，在Activity恢复时的对应方法 重启 任务线程。</li>
</ol>
<p>源码：<a href="https://github.com/guojingyinan/HandlerDemo" target="_blank" rel="noopener">https://github.com/guojingyinan/HandlerDemo</a></p>
<p>原文：<a href="https://my.oschina.net/youranhongcha/blog/1561107w" target="_blank" rel="noopener">https://my.oschina.net/youranhongcha/blog/1561107w</a></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Android/" rel="tag"># Android</a>
          
            <a href="/tags/Android消息机制/" rel="tag"># Android消息机制</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/08/03/Android消息机制/" rel="next" title="Android消息机制">
                <i class="fa fa-chevron-left"></i> Android消息机制
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/08/15/Android应用的的persistent属性/" rel="prev" title="Android应用的的persistent属性">
                Android应用的的persistent属性 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/logo.jpg" alt="zeng">
            
              <p class="site-author-name" itemprop="name">zeng</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">56</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">38</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AsyncTask简介"><span class="nav-number">2.</span> <span class="nav-text">AsyncTask简介</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#AsyncTask的execute"><span class="nav-number">2.1.</span> <span class="nav-text">AsyncTask的execute()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AsyncTask和线程池的协作"><span class="nav-number">2.2.</span> <span class="nav-text">AsyncTask和线程池的协作</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#AsyncTask里的mFuture"><span class="nav-number">2.2.1.</span> <span class="nav-text">AsyncTask里的mFuture</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#AsyncTask里的mWorker"><span class="nav-number">2.2.2.</span> <span class="nav-text">AsyncTask里的mWorker</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#UI线程和AsyncTask工作线程之间的协作"><span class="nav-number">2.2.3.</span> <span class="nav-text">UI线程和AsyncTask工作线程之间的协作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#AsyncTask的内部状态"><span class="nav-number">2.2.4.</span> <span class="nav-text">AsyncTask的内部状态</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#cancel动作"><span class="nav-number">2.2.5.</span> <span class="nav-text">cancel动作</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小结"><span class="nav-number">3.</span> <span class="nav-text">小结</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#注意点"><span class="nav-number">3.1.</span> <span class="nav-text">注意点</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2016 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zeng</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
